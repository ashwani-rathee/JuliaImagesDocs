var documenterSearchIndex = {"docs":
[{"location":"reference/#package_references","page":"Package References","title":"Package References","text":"","category":"section"},{"location":"reference/#High-level-API","page":"Package References","title":"High-level API","text":"","category":"section"},{"location":"reference/","page":"Package References","title":"Package References","text":"ImageBase.restrict\nImageTransformations.imrotate\nImageTransformations.imresize","category":"page"},{"location":"reference/#ImageBase.restrict","page":"Package References","title":"ImageBase.restrict","text":"restrict(img[, dims]) -> imgr\n\nReduce the size of img by approximately two-fold along the dimensions listed in dims, or all spatial coordinates if dims is not specified.\n\nOutput\n\nThe type of output array imgr depends on the input type:\n\nIf img is an OffsetArray, then output array imgr will also be an OffsetArray.\nIf img is not an OffsetArray, then output array imgr will be an Array type even if it has offset indices.\n\nThe size of imgr is approximately 1/2 of the original size. More specifically:\n\nif Nₖ = size(img, k) is odd, then size(imgr, k) == (Nₖ+1) ÷ 2.\nif Nₖ = size(img, k) is even, then size(imgr, k) == (Nₖ÷2) + 1.\n\nExamples\n\nThe optional argument dims can be a Tuple or Integer:\n\nA = rand(5, 5) # size: (5, 5)\n\nrestrict(A) # size: (3, 3)\n\nrestrict(A, 1) # size: (3, 5)\nrestrict(A, 2) # size: (5, 3)\n\nrestrict(A, (1, )) # size: (3, 5)\nrestrict(A, (1, 2)) # size: (3, 3)\n\nUnless the input array is 1-based, the origin will be halfed:\n\njulia> using ImageBase, OffsetArrays\n\njulia> Ao = OffsetArray(rand(5, 4), 5, 6);\n\njulia> Ar = restrict(Ao);\n\njulia> axes(Ao)\n(OffsetArrays.IdOffsetRange(values=6:10, indices=6:10), OffsetArrays.IdOffsetRange(values=7:10, indices=7:10))\n\njulia> axes(Ar)\n(OffsetArrays.IdOffsetRange(values=3:5, indices=3:5), OffsetArrays.IdOffsetRange(values=4:6, indices=4:6))\n\nExtended help\n\nThe term restrict is taken from the coarsening operation of algebraic multigrid methods; it is the adjoint of \"prolongation\" (which is essentially interpolation). restrict anti-aliases the image as it goes, so is better than a naive summation over 2x2 blocks. The implementation of restrict has been tuned for performance, and should be a fast method for constructing pyramids.\n\nIf l is the size of img along a particular dimension, restrict produces an array of size (l+1)÷2 for odd l, and l÷2 + 1 for even l. See the example below for an explanation.\n\nSee also imresize.\n\nExample\n\na_course = [0, 1, 0.3]\n\nIf we were to interpolate this at the halfway points, we'd get\n\na_fine = [0, 0.5, 1, 0.65, 0.3]\n\nNote that a_fine is obtained from a_course via the prolongation operator P as P*a_course, where\n\nP = [1   0   0;      # this line \"copies over\" the first point\n     0.5 0.5 0;      # this line takes the mean of the first and second point\n     0   1   0;      # copy the second point\n     0   0.5 0.5;    # take the mean of the second and third\n     0   0   1]      # copy the third\n\nrestrict is the adjoint of prolongation. Consequently,\n\njulia> restrict(a_fine)\n3-element Array{Float64,1}:\n 0.125\n 0.7875\n 0.3125\n\njulia> (P'*a_fine)/2\n3-element Array{Float64,1}:\n 0.125\n 0.7875\n 0.3125\n\nwhere the division by 2 approximately preserves the mean intensity of the input.\n\nAs we see here, for odd-length a_fine, restriction is the adjoint of interpolation at half-grid points. When length(a_fine) is even, restriction is the adjoint of interpolation at 1/4 and 3/4-grid points. This turns out to be the origin of the l->l÷2 + 1 behavior.\n\nOne consequence of this definition is that the edges move towards zero:\n\njulia> restrict(ones(11))\n6-element Array{Float64,1}:\n 0.75\n 1.0\n 1.0\n 1.0\n 1.0\n 0.75\n\nIn some applications (e.g., image registration), you may find it useful to trim the edges.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageTransformations.imrotate","page":"Package References","title":"ImageTransformations.imrotate","text":"imrotate(img, θ, [indices], [degree = Linear()], [fill = NaN]) -> imgr\n\nRotate image img by θ∈[0,2π) in a clockwise direction around its center point. To rotate the image counterclockwise, specify a negative value for angle.\n\nBy default, rotated image imgr will not be cropped. Bilinear interpolation will be used and values outside the image are filled with NaN if possible, otherwise with 0.\n\nExamples\n\njulia> img = testimage(\"cameraman\")\n\n# rotate with bilinear interpolation but without cropping\njulia> imrotate(img, π/4)\n\n# rotate with bilinear interpolation and with cropping\njulia> imrotate(img, π/4, axes(img))\n\n# rotate with nearest interpolation but without cropping\njulia> imrotate(img, π/4, Constant())\n\nThe keyword `method` now also takes any InterpolationType from Interpolations.jl\nor a Degree, which is used to define a BSpline interpolation of that degree, in\norder to set the interpolation method used during image rotation.\n\n\njulia\n\nrotate with Linear interpolation without cropping\n\njulia> imrotate(img, π/4, method = Linear())\n\nrotate with Lanczos4OpenCV interpolation without cropping\n\njulia> imrotate(img, π/4, method = Lanczos4OpenCV()) ```\n\nSee also warp.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageTransformations.imresize","page":"Package References","title":"ImageTransformations.imresize","text":"imresize(img, sz) -> imgr\nimresize(img, inds) -> imgr\nimresize(img; ratio) -> imgr\n\nChange img to be of size sz (or to have indices inds). If ratio is used, then sz = ceil(Int, size(img).*ratio). This interpolates the values at sub-pixel locations. If you are shrinking the image, you risk aliasing unless you low-pass filter img first.\n\nThe keyword method takes any InterpolationType from Interpolations.jl or a Degree, which is used to define a BSpline interpolation of that degree, in order to set the interpolation method used in the image resizing.\n\nExamples\n\njulia> img = testimage(\"lena_gray_256\") # 256*256\njulia> imresize(img, 128, 128) # 128*128\njulia> imresize(img, 1:128, 1:128) # 128*128\njulia> imresize(img, (128, 128)) # 128*128\njulia> imresize(img, (1:128, 1:128)) # 128*128\njulia> imresize(img, (1:128, )) # 128*256\njulia> imresize(img, 128) # 128*256\njulia> imresize(img, ratio = 0.5) #128*128\njulia> imresize(img, ratio = (2, 1)) # 256*128\njulia> imresize(img, (128,128), method=Linear()) #128*128\njulia> imresize(img, (128,128), method=BSpline(Linear())) #128*128\njulia> imresize(img, (128,128), method=Lanczos4OpenCV()) #128*128\n\nσ = map((o,n)->0.75*o/n, size(img), sz)\nkern = KernelFactors.gaussian(σ)   # from ImageFiltering\nimgr = imresize(imfilter(img, kern, NA()), sz)\n\nSee also restrict.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Low-level-warping-API","page":"Package References","title":"Low-level warping API","text":"","category":"section"},{"location":"reference/","page":"Package References","title":"Package References","text":"ImageTransformations.warp\nImageTransformations.WarpedView\nImageTransformations.InvWarpedView\nImageTransformations.invwarpedview","category":"page"},{"location":"reference/#ImageTransformations.warp","page":"Package References","title":"ImageTransformations.warp","text":"warp(img, tform, [indices], [degree = Linear()], [fill = NaN]) -> imgw\n\nTransform the coordinates of img, returning a new imgw satisfying imgw[I] = img[tform(I)]. This approach is known as backward mode warping. The transformation tform must accept a SVector as input. A useful package to create a wide variety of such transformations is CoordinateTransformations.jl.\n\nReconstruction scheme\n\nDuring warping, values for img must be reconstructed at arbitrary locations tform(I) which do not lie on to the lattice of pixels. How this reconstruction is done depends on the type of img and the optional parameter degree.\n\nWhen img is a plain array, then on-grid b-spline interpolation will be used. It is possible to configure what degree of b-spline to use with the parameter degree. For example one can use degree = Linear() for linear interpolation, degree = Constant() for nearest neighbor interpolation, or degree = Quadratic(Flat()) for quadratic interpolation.\n\nIn the case tform(I) maps to indices outside the original img, those locations are set to a value fill (which defaults to NaN if the element type supports it, and 0 otherwise). The parameter fill also accepts extrapolation schemes, such as Flat(), Periodic() or Reflect().\n\nFor more control over the reconstruction scheme –- and how beyond-the-edge points are handled –- pass img as an AbstractInterpolation or AbstractExtrapolation from Interpolations.jl.\n\nThe keyword method now also takes any InterpolationType from Interpolations.jl or a Degree, which is used to define a BSpline interpolation of that degree, in order to set the interpolation method used.\n\nThe meaning of the coordinates\n\nThe output array imgw has indices that would result from applying inv(tform) to the indices of img. This can be very handy for keeping track of how pixels in imgw line up with pixels in img.\n\nIf you just want a plain array, you can \"strip\" the custom indices with parent(imgw).\n\nExamples: a 2d rotation (see JuliaImages documentation for pictures)\n\njulia> using Images, CoordinateTransformations, Rotations, TestImages, OffsetArrays\n\njulia> img = testimage(\"lighthouse\");\n\njulia> axes(img)\n(Base.OneTo(512),Base.OneTo(768))\n\n# Rotate around the center of `img`\njulia> tfm = recenter(RotMatrix(-pi/4), center(img))\nAffineMap([0.707107 0.707107; -0.707107 0.707107], [-196.755,293.99])\n\njulia> imgw = warp(img, tfm);\n\njulia> axes(imgw)\n(-196:709,-68:837)\n\n# Alternatively, specify the origin in the image itself\njulia> img0 = OffsetArray(img, -30:481, -384:383);  # origin near top of image\n\njulia> rot = LinearMap(RotMatrix(-pi/4))\nLinearMap([0.707107 -0.707107; 0.707107 0.707107])\n\njulia> imgw = warp(img0, rot);\n\njulia> axes(imgw)\n(-293:612,-293:611)\n\njulia> imgr = parent(imgw);\n\n\njldoctest using ImageTransformations, CoordinateTransformations, Rotations, TestImages, OffsetArrays using OffsetArrays: IdOffsetRange img = testimage(\"lighthouse\") # axes (1:512, 1:768)\n\ntfm = recenter(RotMatrix(-pi/4), center(img)) imgw = warp(img, tfm)\n\naxes(imgw)\n\noutput\n\n(IdOffsetRange(values=-196:709, indices=-196:709), IdOffsetRange(values=-68:837, indices=-68:837)) ```\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageTransformations.WarpedView","page":"Package References","title":"ImageTransformations.WarpedView","text":"WarpedView(img, tform, [indices]) -> wv\n\nCreate a view of img that lazily transforms any given index I passed to wv[I] to correspond to img[tform(I)]. This approach is known as backward mode warping.\n\nThe optional parameter indices can be used to specify the domain of the resulting wv. By default the indices are computed in such a way that wv contains all the original pixels in img. To do this inv(tform) has to be computed. If the given transformation tform does not support inv, then the parameter indices has to be specified manually.\n\nsee warpedview for more information.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ImageTransformations.InvWarpedView","page":"Package References","title":"ImageTransformations.InvWarpedView","text":"InvWarpedView(img, tinv, [indices]) -> wv\n\nCreate a view of img that lazily transforms any given index I passed to wv[I] to correspond to img[inv(tinv)(I)]. While technically this approach is known as backward mode warping, note that InvWarpedView is created by supplying the forward transformation\n\nThe conceptual difference to WarpedView is that InvWarpedView is intended to be used when reasoning about the image is more convenient that reasoning about the indices. Furthermore, InvWarpedView allows simple nesting of transformations, in which case the transformations will be composed into a single one.\n\nThe optional parameter indices can be used to specify the domain of the resulting wv. By default the indices are computed in such a way that wv contains all the original pixels in img.\n\nsee invwarpedview for more information.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ImageTransformations.invwarpedview","page":"Package References","title":"ImageTransformations.invwarpedview","text":"invwarpedview(img, tinv, [indices], [degree = Linear()], [fill = NaN]) -> wv\n\nCreate a view of img that lazily transforms any given index I passed to wv[I] to correspond to img[inv(tinv)(I)]. While technically this approach is known as backward mode warping, note that InvWarpedView is created by supplying the forward transformation. The given transformation tinv must accept a SVector as input and support inv(tinv). A useful package to create a wide variety of such transformations is CoordinateTransformations.jl.\n\nWhen invoking wv[I], values for img must be reconstructed at arbitrary locations inv(tinv)(I). InvWarpedView serves as a wrapper around WarpedView which takes care of interpolation and extrapolation. The parameters degree and fill can be used to specify the b-spline degree and the extrapolation scheme respectively.\n\nThe optional parameter indices can be used to specify the domain of the resulting wv. By default the indices are computed in such a way that wv contains all the original pixels in img.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Utilities","page":"Package References","title":"Utilities","text":"","category":"section"},{"location":"reference/","page":"Package References","title":"Package References","text":"ImageTransformations.autorange","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Operations","page":"Examples","title":"Operations","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"card-section\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"card\">\n<div class=\"card-cover\">\n<div class=\"card-description\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we illustrate how to construct a custom warping map and pass it to warp. This swirl example comes from the Princeton Computer Graphics course for Image Warping (Fall 2000) and scikit-image swirl example.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: card-cover-image)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n<div class=\"card-text\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Swirl effect using warp operation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"#ImageTransformations.jl","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"","category":"section"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"using ImageShow","category":"page"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"This package provides support for image resizing, image rotation, and other spatial transformations of arrays.","category":"page"},{"location":"#Overview","page":"ImageTransformations.jl","title":"Overview","text":"","category":"section"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"ImageTransformations.jl consists of two sets of API: the low level warping operations, and the high-level operations that built on top of it.","category":"page"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"Low-level warping API:\nwarp: backward-mode warping\nWarpedView: the lazy view version of warp\nInvWarpedView: the inverse of WarpedView\nhigh-level spatial operations:\nimresize: aspect adjustment\nrestrict: a much more efficient version of imresize that two-folds/down-samples image to approximate 1/2 size. (This is now provided by ImageBase.)\nimrotate: rotation","category":"page"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"For detailed usage of these functions, please refer to function references and examples. The following section explains the core concept image warping so that you can get a clear understanding about this package while using it.","category":"page"},{"location":"#index_image_warping","page":"ImageTransformations.jl","title":"Image warping","text":"","category":"section"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"info: Info\nThis is just a very simple explaination on the internal of ImageTransformations. For more information about image warping, you can take a look at the Princeton Computer Graphics course for Image Warping (Fall 2000)","category":"page"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"Most image spatial transformation operations (e.g., rotation, resizing, translation) fall into the category of warping operation. Mathematically, for given input image X, a (backward-mode) warping operation f consists of two functions: coordination map ϕ and intensity estimator τ.","category":"page"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"Y_ij = f(X)_i j = τ(X ϕ(i j))","category":"page"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"Take the following resizing operation as an example, for every pixel position p in output image Y, we 1) use the backward coordinate map ϕ to get its corresponding pixel position q in original image X. Since q may not be on grid, we need to 2) estimate the value of X on position q using function τ, and finally 3) assign X[q] back to Y[p]. In Julia words, it is","category":"page"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"for p in CartesianIndexes(Y)\n    q = ϕ(p) # backward coordinate map\n    v = τ(X, q) # estimate the value\n    Y[p] = v # assign value back\nend","category":"page"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"As you may have notice, we use backward coordinate map because this is the simplest way to iterate every pixel of the output image. This is why it is called backward-mode warping. In some literature, it is also called reverse warping.","category":"page"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"(Image: warp resize demo)","category":"page"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"In ImageTransformations, the warp-based operation uses Interpolations as our intensity estimator τ:","category":"page"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"using Interpolations, ImageCore, TestImages\nusing ImageTransformations\n\nX = imresize(testimage(\"cameraman\"), (64, 64)) # use small image as an example\n\nsz = (128, 128)\nY = similar(X, sz...)\n\n# intensity estimator using interpolation\nitp = interpolate(X, BSpline(Linear())) # bilinear interpolation\nτ(q) = itp(q...)\n\n# A linear coordinate map that satisfies:\n#   - `ϕ(1, 1) == (1, 1)`\n#   - `ϕ(128, 128) == (64, 64)`\nK = (size(X) .- (1, 1))./(sz .- (1, 1))\nb = (1, 1) .- K\nϕ(p) = @. K*p + b\n\nfor p in CartesianIndices(Y)\n    q = ϕ(p.I)\n    Y[p] = τ(q)\nend\n\nmosaic(X, Y; nrow=1)","category":"page"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"This is the internal of ImageTransformations. For common usage of ImageTransformations, you should use either the low-level API warp or high-level API imresize and others.","category":"page"},{"location":"examples/operations/swirl/#Swirl-effect-using-warp-operation","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"","category":"section"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"(Image: Source code) (Image: notebook) (Image: Author) (Image: Update time)","category":"page"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"In this example, we illustrate how to construct a custom warping map and pass it to warp. This swirl example comes from the Princeton Computer Graphics course for Image Warping (Fall 2000) and scikit-image swirl example.","category":"page"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"using ImageTransformations\nusing OffsetArrays, StaticArrays\nusing ImageShow, TestImages\nusing LinearAlgebra\n\nimg = imresize(testimage(\"cameraman\"), (256, 256));\nnothing #hide","category":"page"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"As we've illustrated in image warping, a warp operation consists of two operations: backward coordinate map ϕ and intensity estimator. To implement swirl operation, we need to customize the coordinate map ϕ. A valid coordinate map q = ϕ(p) follows the following interface:","category":"page"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"# SVector comes from StaticArrays\nϕ(::SVector{N})::SVector{N} where N","category":"page"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"A cartesian position (x, y) can be transfered to/from polar coordinate (ρ, θ) using formula:","category":"page"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"# Cartesian to Polar\nρ = norm(y-y0, x-x0)\nθ = atan(y/x)\n\n# Polar to Cartesian\ny = y0 + ρ*sin(θ)\nx = x0 + ρ*cos(θ)","category":"page"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"For given input index p, a swirl operation enforces more rotations in its polar coordinate using θ̃ = θ + ϕ + s*exp(-ρ/r), and returns the cartesian index (x̃, ỹ) from the warped polor coordinate (ρ, θ̃). (Here we use the formula from scikit-image swirl example to build our version.)","category":"page"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"function swirl(rotation, strength, radius)\n    x0 = OffsetArrays.center(img)\n    r = log(2)*radius/5\n\n    function swirl_map(x::SVector{N}) where N\n        xd = x .- x0\n        ρ = norm(xd)\n        θ = atan(reverse(xd)...)\n\n        # Note that `x == x0 .+ ρ .* reverse(sincos(θ))`\n        # swirl adds more rotations to θ based on the distance to center point\n        θ̃ = θ + rotation + strength * exp(-ρ/r)\n\n        SVector{N}(x0 .+ ρ .* reverse(sincos(θ̃)))\n    end\n\n    warp(img, swirl_map, axes(img))\nend","category":"page"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"Now let's see how radius argument affects the result","category":"page"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"preview = ImageShow.gif([swirl(0, 10, radius) for radius in 10:10:150]; fps=5)","category":"page"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"","category":"page"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"}]
}
