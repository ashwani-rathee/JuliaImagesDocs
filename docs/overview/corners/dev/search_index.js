var documenterSearchIndex = {"docs":
[{"location":"","page":"ImageCorners.jl","title":"ImageCorners.jl","text":"CurrentModule = ImageCorners","category":"page"},{"location":"#ImageCorners.jl","page":"ImageCorners.jl","title":"ImageCorners.jl","text":"","category":"section"},{"location":"","page":"ImageCorners.jl","title":"ImageCorners.jl","text":"ImageCorners.jl provides image corner related algorithms in Julia. ","category":"page"},{"location":"#Supported-Algorithms","page":"ImageCorners.jl","title":"Supported Algorithms","text":"","category":"section"},{"location":"","page":"ImageCorners.jl","title":"ImageCorners.jl","text":"Harris \nShi-Tomasi \nKitchen and Rosenfeld \nFAST Corners","category":"page"},{"location":"","page":"ImageCorners.jl","title":"ImageCorners.jl","text":"These Algorithms can be accessed using the following methods:","category":"page"},{"location":"","page":"ImageCorners.jl","title":"ImageCorners.jl","text":"julia> using ImageCorners, TestImages\n\njulia> img = testimage(\"mandrill\");\n\n# corner detection using harris method\njulia> corners = imcorner(img; method = harris);\n\n# threshold can be specified for the thresolding the corner pixels\njulia> corners = imcorner(img, 0.001; method = harris);\n\njulia> corners = imcorner(img, Percentile(95); method = harris);\n\n# for corner detection to subpixel precision imgcorner_subpixel can be used\njulia> corners = imcorner_subpixel(img; method = harris);","category":"page"},{"location":"","page":"ImageCorners.jl","title":"ImageCorners.jl","text":"Modules = [ImageCorners]","category":"page"},{"location":"#ImageCorners.HomogeneousPoint","page":"ImageCorners.jl","title":"ImageCorners.HomogeneousPoint","text":"HomogeneousPoint(x::NTuple{N, T}) In projective geometry homogeneous coordinates are the natural coordinates for describing points and lines. For instance, the homogeneous coordinates for a planar point are a triplet of real numbers (u v w), with w neq 0. This triple can be associated with a point P = (xy) in Cartesian coordinates, where x = fracuw and y = fracvw (more details). In particular, the HomogeneousPoint((10.0,5.0,1.0)) is the standardised projective representation of the Cartesian point (10.0,5.0).\n\n\n\n\n\n","category":"type"},{"location":"#ImageCorners.Percentile","page":"ImageCorners.jl","title":"ImageCorners.Percentile","text":"Percentile(x)\n\nIndicate that x should be interpreted as a percentile rather than an absolute value. For example,\n\ncanny(img, 1.4, (80, 20)) uses absolute thresholds on the edge magnitude image\ncanny(img, 1.4, (Percentile(80), Percentile(20))) uses percentiles of the edge magnitude image as threshold\n\n\n\n\n\n","category":"type"},{"location":"#ImageCorners.corner2subpixel-Tuple{AbstractMatrix, AbstractMatrix{Bool}}","page":"ImageCorners.jl","title":"ImageCorners.corner2subpixel","text":"corners = corner2subpixel(responses::AbstractMatrix,corner_indicator::AbstractMatrix{Bool})\n        -> Vector{HomogeneousPoint{Float64,3}}\n\nRefines integer corner coordinates to sub-pixel precision. The function takes as input a matrix representing corner responses and a boolean indicator matrix denoting the integer coordinates of a corner in the image. The output is a vector of type HomogeneousPoint storing the sub-pixel coordinates of the corners. The algorithm computes a correction factor which is added to the original integer coordinates. In particular, a univariate quadratic polynomial is fit separately to the x-coordinates and y-coordinates of a corner and its immediate east/west, and north/south neighbours. The fit is achieved using a local coordinate system for each corner, where the origin of the coordinate system is a given corner, and its immediate neighbours are assigned coordinates of  minus one and plus one. The corner and its two neighbours form a system of three equations. For example, let  x_1 = -1,  x_2 = 0 and  x_3 = 1 denote the local x coordinates of the west, center and east pixels and let the vector mathbfb = r_1 r_2 r_3 denote the corresponding corner response values. With\n\n    mathbfA =\n        beginbmatrix\n            x_1^2  x_1   1  \n            x_2^2  x_2   1 \n            x_3^2  x_3   1 \n        endbmatrix\n\nthe coefficients of the quadratic polynomial can be found by solving the system of equations mathbfb = mathbfAmathbfx. The result is given by x = mathbfA^-1mathbfb. The vertex of the quadratic polynomial yields a sub-pixel estimate of the true corner position. For example, for a univariate quadratic polynomial px^2 + qx + r, the x-coordinate of the vertex is frac-q2p. Hence, the refined sub-pixel coordinate is equal to:  c +  frac-q2p, where c is the integer coordinate.\n\nnote: Note\nCorners on the boundary of the image are not refined to sub-pixel precision.\n\n\n\n\n\n","category":"method"},{"location":"#ImageCorners.fastcorners-Union{Tuple{AbstractArray{T}}, Tuple{T}, Tuple{AbstractArray{T}, Int64}, Tuple{AbstractArray{T}, Int64, Float64}} where T","page":"ImageCorners.jl","title":"ImageCorners.fastcorners","text":"fastcorners(img, n, threshold) -> corners\n\nPerforms FAST Corner Detection. n is the number of contiguous pixels which need to be greater (lesser) than intensity + threshold (intensity - threshold) for a pixel to be marked as a corner. The default value for n is 12.\n\n\n\n\n\n","category":"method"},{"location":"#ImageCorners.harris-Tuple{AbstractArray}","page":"ImageCorners.jl","title":"ImageCorners.harris","text":"harris_response = harris(img; [k], [border], [weights])\n\nPerforms Harris corner detection. The covariances can be taken using either a mean weighted filter or a gamma kernel.\n\n\n\n\n\n","category":"method"},{"location":"#ImageCorners.imcorner-Tuple{AbstractArray}","page":"ImageCorners.jl","title":"ImageCorners.imcorner","text":"corners = imcorner(img; [method])\ncorners = imcorner(img, threshold; [method])\n\nPerforms corner detection using one of the following methods -     1. harris     2. shitomasi     3. kitchenrosenfeld The parameters of the individual methods are described in their documentation. The maxima values of the resultant responses are taken as corners. If a threshold is specified, the values of the responses are thresholded to give the corner pixels. If threshold is a Percentile then its type will be preserved.\n\n\n\n\n\n","category":"method"},{"location":"#ImageCorners.imcorner_subpixel-Tuple{AbstractArray}","page":"ImageCorners.jl","title":"ImageCorners.imcorner_subpixel","text":"corners = imcorner_subpixel(img; [method])\n         -> Vector{HomogeneousPoint{Float64,3}}\ncorners = imcorner_subpixel(img, threshold, percentile; [method])\n         -> Vector{HomogeneousPoint{Float64,3}}\n\nSame as imcorner, but estimates corners to sub-pixel precision. Sub-pixel precision is achieved by interpolating the corner response values using the 4-connected neighbourhood of a maximum response value. See corner2subpixel for more details of the interpolation scheme.\n\n\n\n\n\n","category":"method"},{"location":"#ImageCorners.kitchen_rosenfeld-Tuple{AbstractArray}","page":"ImageCorners.jl","title":"ImageCorners.kitchen_rosenfeld","text":"kitchen_rosenfeld_response = kitchen_rosenfeld(img; [border])\n\nPerforms Kitchen Rosenfeld corner detection. The covariances can be taken using either a mean weighted filter or a gamma kernel.\n\n\n\n\n\n","category":"method"},{"location":"#ImageCorners.shi_tomasi-Tuple{AbstractArray}","page":"ImageCorners.jl","title":"ImageCorners.shi_tomasi","text":"shi_tomasi_response = shi_tomasi(img; [border], [weights])\n\nPerforms Shi Tomasi corner detection. The covariances can be taken using either a mean weighted filter or a gamma kernel.\n\n\n\n\n\n","category":"method"},{"location":"#ImageCorners.unsafe_neighbourhood_4-Tuple{AbstractMatrix, Int64, Int64}","page":"ImageCorners.jl","title":"ImageCorners.unsafe_neighbourhood_4","text":"unsafe_neighbourhood_4(matrix::AbstractMatrix,r::Int,c::Int)\n\nReturns the value of a matrix at given coordinates together with the values of the north, south, east and west neighbours. This function does not perform bounds checking. It is up to the user to ensure that the function is not called with indices that are on the boundary of the matrix.\n\n\n\n\n\n","category":"method"}]
}
